plugins {
    id "local.versions"

    id 'java-library'
    id 'maven-publish'
    alias(libs.plugins.com.diffplug.spotless)
    alias(libs.plugins.org.asciidoctor.jvm.convert) apply false
}

group = "org.hibernate.reactive"
// leverage the ProjectVersion which comes from the `local.versions` plugin
version = project.projectVersion.fullName

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'com.diffplug.spotless'

    group = rootProject.group
    version = rootProject.version

    spotless {
        //Don't fail during the check: rather than enforcing guidelines, we use this plugin to fix mistakes automatically.
        enforceCheck false
        java {
            licenseHeaderFile rootProject.file('spotless.license.java')
            removeUnusedImports()
            trimTrailingWhitespace()
            endWithNewline()
        }
    }

    tasks.compileJava.dependsOn(spotlessApply)

    repositories {
        // Example: ./gradlew build -PenableMavenLocalRepo
        if ( project.hasProperty('enableMavenLocalRepo') ) {
            // Useful for local development, it should be disabled otherwise
            mavenLocal()
        }
        // Example: ./gradlew build -PenableCentralSonatypeSnapshotsRep
        if ( project.hasProperty('enableCentralSonatypeSnapshotsRep') ) {
            maven { url 'https://central.sonatype.com/repository/maven-snapshots/' }
        }

        mavenCentral()
    }
    
    ext.publishScript = rootProject.rootDir.absolutePath + '/publish.gradle'

    tasks.withType( JavaCompile ).configureEach {
        options.encoding = 'UTF-8'
    }

    // Configure test tasks for all subprojects
    tasks.withType( Test ).configureEach {
        // Set the project root for finding Docker files - available to all modules
        systemProperty 'hibernate.reactive.project.root', rootProject.projectDir.absolutePath
    }

    if ( !gradle.ext.javaToolchainEnabled ) {
        sourceCompatibility = JavaVersion.toVersion( gradle.ext.baselineJavaVersion )
        targetCompatibility = JavaVersion.toVersion( gradle.ext.baselineJavaVersion )
    }
    else {
        // Configure generated bytecode
        // "sourceCompatibility" is not supported with toolchains. We have to work around that limitation.
        tasks.compileJava.configure {
            options.release = gradle.ext.javaVersions.main.release.asInt()
        }
        tasks.compileTestJava.configure {
            options.release = gradle.ext.javaVersions.test.release.asInt()
        }

	    // Configure version of Java tools
        java {
            toolchain {
                languageVersion = gradle.ext.javaVersions.main.compiler
            }
        }
        tasks.compileTestJava {
            javaCompiler = javaToolchains.compilerFor {
                languageVersion = gradle.ext.javaVersions.test.compiler
            }
        }
        tasks.test {
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = gradle.ext.javaVersions.test.launcher
            }
        }

        // Configure JVM Options
        tasks.withType( JavaCompile ).configureEach {
            options.forkOptions.jvmArgs.addAll( getProperty( 'toolchain.compiler.jvmargs' ).toString().split( ' ' ) )
        }
        tasks.withType( Javadoc ).configureEach {
		    options.setJFlags( getProperty( 'toolchain.javadoc.jvmargs' ).toString().split( ' ' ).toList().findAll( { !it.isEmpty() } ) )
        }
        tasks.test {
            // Configure JVM Options
            jvmArgs(getProperty('toolchain.launcher.jvmargs').toString().split(' '))
            if ( project.hasProperty( 'test.jdk.launcher.args' ) ) {
                jvmArgs( project.getProperty( 'test.jdk.launcher.args' ).toString().split( ' ' ) )
            }
        }

	    // Display version of Java tools
        tasks.withType( JavaCompile ).configureEach {
            doFirst {
                logger.lifecycle "Compiling with '${javaCompiler.get().metadata.installationPath}'"
            }
        }
        tasks.withType( Javadoc ).configureEach {
            doFirst {
                logger.lifecycle "Generating javadoc with '${javadocTool.get().metadata.installationPath}'"
            }
        }
        tasks.test {
            doFirst {
                logger.lifecycle "Testing with '${javaLauncher.get().metadata.installationPath}'"
            }
        }
    }
}

rootProject.afterEvaluate {
    // Workaround since "libs.versions.NAME" notation cannot be used here
    def libs = project.extensions.getByType(VersionCatalogsExtension).named('libs')
    logger.lifecycle "ORM version: ${libs.findVersion('hibernateOrmVersion').get().requiredVersion}"
    logger.lifecycle "ORM Gradle plugin version: ${libs.findVersion('hibernateOrmGradlePluginVersion').get().requiredVersion}"
    logger.lifecycle "Vert.x SQL Client version: ${libs.findVersion('vertxSqlClientVersion').get().requiredVersion}"
}
