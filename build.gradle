import java.util.regex.Pattern

plugins {
    id 'java-library'
    id 'maven-publish'
    id 'com.diffplug.gradle.spotless' version '4.0.1'
    id 'nu.studer.credentials' version '2.1' apply false
    id 'com.jfrog.bintray' version '1.8.5' apply false
    id 'org.asciidoctor.convert' version '1.5.7' apply false
}

ext {
    projectVersionFile = file( "${rootProject.projectDir}/gradle/version.properties" )
    projectVersion = Version.parseProjectVersion( readVersionFromProperties( projectVersionFile ) )

    if ( project.hasProperty('releaseVersion') ) {
        releaseVersion = Version.parseReleaseVersion( project.releaseVersion )
    }
    if ( project.hasProperty('developmentVersion') ) {
        developmentVersion = Version.parseDevelopmentVersion( project.developmentVersion )
    }
}

// Versions which need to be aligned across modules; this also
// allows overriding the build using a parameter, which can be
// useful to monitor compatibility for upcoming versions on CI:
//
// ./gradlew clean build -PhibernateOrmVersion=5.4.9-SNAPSHOT

ext {
    if ( !project.hasProperty('hibernateOrmVersion') ) {
        hibernateOrmVersion = '5.4.23.Final'
    }
    // For ORM, we need a parsed version (to get the family, ...)

    // For ORM, we need a parsed version (to get the family for the documentation during release).
    // We use intervals to build with the latest ORM snapshot and this will fail version check.
    // Because we don't need to publish or release anything we can disable the check in this case.
    // Example:
    // ./gradlew build -PhibernateOrmVersion='[5.4,5.5)' -PskipOrmVersionParsing
    if ( project.hasProperty( 'skipOrmVersionParsing' ) ) {
        // Default to true if the property is null
        skipOrmVersionParsing = project.skipOrmVersionParsing ?: true
    }
    else {
        skipOrmVersionParsing = false
    }

    if ( !Boolean.valueOf( project.skipOrmVersionParsing ) ) {
        logger.lifecycle "Parsing ORM version"
        hibernateOrmVersion = Version.parseProjectVersion( project.hibernateOrmVersion )
    }

    // Mainly, to allow CI to test the latest versions of Vert.X
    // Example:
    // ./gradlew build -PvertxVersion=4.0.0-SNAPSHOT
    if ( !project.hasProperty('vertxVersion') ) {
        vertxVersion = '3.9.4'
    }

    testcontainersVersion = '1.14.3'

    logger.lifecycle "Hibernate ORM Version: " + project.hibernateOrmVersion
    logger.lifecycle "Vert.x Version: " + project.vertxVersion

    baselineJavaVersion = JavaLanguageVersion.of( 8 )

    // Gradle does bytecode transformation on tests.
    // You can't use bytecode higher than what Gradle supports, even with toolchains.
    def GRADLE_MAX_SUPPORTED_BYTECODE_VERSION = 15

    // If either 'main.jdk.version' or 'test.jdk.version' is set, enable the toolchain and use the selected jdk.
    // If only one property is set, the other defaults to the baseline Java version (8).
    // Note that when toolchain is enabled, you also need to specify
    // the location of the selected jdks
    // (auto-download and auto-detect are disabled in gradle.properties).
    //
    // Example (with SDKMAN):
    // ./gradlew build -Ptest.jdk.version=15 \
    // -Porg.gradle.java.installations.paths=$SDKMAN_CANDIDATES_DIR/java/15.0.1-open,$SDKMAN_CANDIDATES_DIR/java/8
    if ( project.hasProperty( 'main.jdk.version' ) || project.hasProperty( 'test.jdk.version' ) ) {
        // Testing a particular JDK version
        // Gradle doesn't support all JDK versions unless we use toolchains
        javaToolchainEnabled = true
        javaVersions = [
                main: [
                        compiler: JavaLanguageVersion.of( project.findProperty( 'main.jdk.version' )
                                ?: baselineJavaVersion.asInt() ),
                        release: baselineJavaVersion
                ],
                test: [
                        compiler: JavaLanguageVersion.of( project.findProperty( 'test.jdk.version' )
                                ?: baselineJavaVersion.asInt() )
                ]
        ]
        def testCompilerVersion = javaVersions.test.compiler
        if ( testCompilerVersion.asInt() > GRADLE_MAX_SUPPORTED_BYTECODE_VERSION ) {
            logger.warn( "[WARN] Gradle does not support bytecode version '${testCompilerVersion}'." +
                     " Forcing test bytecode to version ${GRADLE_MAX_SUPPORTED_BYTECODE_VERSION}." )
            javaVersions.test.release = JavaLanguageVersion.of( GRADLE_MAX_SUPPORTED_BYTECODE_VERSION )
        }
        else {
            javaVersions.test.release = testCompilerVersion
        }
        javaVersions.test.launcher = testCompilerVersion
    }
    else {
        // Not testing a particular JDK version: we will use the same JDK used to run Gradle.
        // We disable toolchains for convenience, so that anyone can just run the build with their own JDK
        // without any additional options and without downloading the whole JDK.
        javaToolchainEnabled = false
        def gradleJdkVersion = JavaLanguageVersion.of( JavaVersion.current().getMajorVersion() )
        if ( gradleJdkVersion.asInt() > GRADLE_MAX_SUPPORTED_BYTECODE_VERSION ) {
            logger.warn( "[WARN] Gradle does not support this JDK, because it is too recent; build is likely to fail." +
                    " To avoid failures, you should use an older Java version when running Gradle, and rely on toolchains." +
                    " To that end, specify the version of Java you want to run tests with using property 'test.jdk.version'," +
                    " and specify the path to JDK8 *and* a JDK of the test version using property 'org.gradle.java.installations.paths'." +
                    " Example:" +
                    "./gradlew build -Ptest.jdk.version=15 -Porg.gradle.java.installations.paths=\$SDKMAN_CANDIDATES_DIR/java/15.0.1-open,\$SDKMAN_CANDIDATES_DIR/java/8" )
        }

        javaVersions = [
                main: [
                        compiler: gradleJdkVersion,
                        release: baselineJavaVersion
                ],
                test: [
                        compiler: gradleJdkVersion,
                        release: gradleJdkVersion,
                        launcher: gradleJdkVersion
                ]
        ]
    }

    logger.lifecycle "Java versions for main code: " + project.javaVersions.main
    logger.lifecycle "Java versions for tests: " + project.javaVersions.test
}

subprojects {
    apply plugin: 'java-library'
    apply plugin: 'com.diffplug.gradle.spotless'
    group = 'org.hibernate.reactive'
    version = projectVersion

    compileJava.options.encoding = 'UTF-8'
    compileTestJava.options.encoding = 'UTF-8'

    if ( project.javaToolchainEnabled ) {
        // "sourceCompatibility" is not supported with toolchains. We have to work around that limitation.
        compileJava.configure {
            if ( project.project.javaVersions.main.compiler.asInt() < 9 ) {
                options.compilerArgs << '-source'
                options.compilerArgs << project.javaVersions.main.release.toString()
                options.compilerArgs << '-target'
                options.compilerArgs << project.javaVersions.main.release.toString()
            } else {
                options.release = project.javaVersions.main.release.asInt()
            }
        }
        compileTestJava.configure {
            if ( project.project.javaVersions.test.compiler.asInt() < 9 ) {
                options.compilerArgs << '-source'
                options.compilerArgs << project.javaVersions.test.release.toString()
                options.compilerArgs << '-target'
                options.compilerArgs << project.javaVersions.test.release.toString()
            } else {
                options.release = project.javaVersions.test.release.asInt()
            }
        }
    }
    else {
        sourceCompatibility = JavaVersion.toVersion( project.baselineJavaVersion )
        targetCompatibility = JavaVersion.toVersion( project.baselineJavaVersion )
    }

    repositories {
        // Only enable these for local development, never push it:
        // mavenLocal()
        // jcenter()
        // maven { url 'https://oss.sonatype.org/content/repositories/snapshots' }
        mavenCentral()

        // Example: ./gradlew build -PenableJBossSnapshotsRep
        if ( project.hasProperty('enableJBossSnapshotsRep') ) {
            // Used only for testing with the latest Hibernate ORM snapshots.
            maven { url 'https://repository.jboss.org/nexus/content/repositories/snapshots' }
        }
    }
    
    ext.publishScript = rootProject.rootDir.absolutePath + '/publish.gradle'

    if ( project.javaToolchainEnabled ) {
        java {
            toolchain {
                languageVersion = project.javaVersions.main.compiler
            }
        }
        tasks.withType( JavaCompile ).configureEach {
            doFirst {
                logger.lifecycle "Compiling with '${javaCompiler.get().metadata.installationPath}'"
            }
        }
        compileTestJava {
            javaCompiler = javaToolchains.compilerFor {
                languageVersion = project.javaVersions.test.compiler
            }
        }
        tasks.withType( Javadoc ).configureEach {
            doFirst {
                logger.lifecycle "Generating javadoc with '${javadocTool.get().metadata.installationPath}'"
            }
        }
        test {
            javaLauncher = javaToolchains.launcherFor {
                languageVersion = project.javaVersions.test.launcher
            }
            doFirst {
                logger.lifecycle "Testing with '${javaLauncher.get().metadata.installationPath}'"
            }
        }
    }
}

private static String readVersionFromProperties(File file) {
    if ( !file.exists() ) {
        throw new GradleException( "Version file $file.canonicalPath does not exists" )
    }
    Properties versionProperties = new Properties()
    file.withInputStream {
        stream -> versionProperties.load( stream )
    }
    return versionProperties.projectVersion
}

class Version {

    private static final Pattern RELEASE_VERSION_PATTERN = ~/^(\d+)\.(\d+)\.(\d+)\.((?<=\.0\.)(?:Alpha\d+|Beta\d+|CR\d+)|Final)$/

    private static final Pattern DEVELOPMENT_VERSION_PATTERN = ~/^(\d+)\.(\d+)\.(\d+)-SNAPSHOT$/

    static Version parseReleaseVersion(String versionString) {
        def matcher = (versionString =~ RELEASE_VERSION_PATTERN)
        if ( !matcher.matches() ) {
            throw new IllegalArgumentException(
                    "Invalid version number: '$versionString'." +
                            " Release version numbers must match /$RELEASE_VERSION_PATTERN/."
            )
        }
        return new Version( matcher.group(1), matcher.group(2), matcher.group(3), matcher.group(4), false )
    }

    static Version parseDevelopmentVersion(String versionString) {
        def matcher = (versionString =~ DEVELOPMENT_VERSION_PATTERN)
        if ( !matcher.matches() ) {
            throw new IllegalArgumentException(
                    "Invalid version number: '$versionString'." +
                            " Development version numbers must match /$DEVELOPMENT_VERSION_PATTERN/."
            )
        }

        return new Version( matcher.group(1), matcher.group(2), matcher.group(3), null, true )
    }

    static Version parseProjectVersion(String versionString) {
        if ( (versionString =~ RELEASE_VERSION_PATTERN).matches() ) {
            return parseReleaseVersion( versionString )
        }
        if ( (versionString =~ DEVELOPMENT_VERSION_PATTERN).matches() ) {
            return parseDevelopmentVersion( versionString )
        }
        throw new IllegalArgumentException(
                "Invalid version number: '$versionString'." +
                        " Project version numbers must match either /$RELEASE_VERSION_PATTERN/ or /$DEVELOPMENT_VERSION_PATTERN/."
        )
    }

    final String major
    final String minor
    final String micro
    final String qualifier
    final boolean snapshot

    Version(String major, String minor, String micro, String qualifier, boolean snapshot) {
        this.major = major
        this.minor = minor
        this.micro = micro
        this.qualifier = qualifier
        this.snapshot = snapshot
    }

    @Override
    String toString() {
        [major, minor, micro, qualifier].findAll({ it != null }).join('.') + (snapshot ? '-SNAPSHOT' : '')
    }

    String getFamily() {
        "$major.$minor"
    }
}
