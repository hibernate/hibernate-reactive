/* Hibernate, Relational Persistence for Idiomatic Java
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright: Red Hat Inc. and Hibernate Authors
 */
package org.hibernate.reactive;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hibernate.reactive.containers.DatabaseConfiguration.DBType.COCKROACHDB;
import static org.hibernate.reactive.testing.DatabaseSelectionRule.runOnlyFor;
import static org.hibernate.reactive.testing.ReactiveAssertions.assertThrown;


import org.hibernate.cfg.AvailableSettings;
import org.hibernate.cfg.Configuration;
import org.hibernate.reactive.testing.DatabaseSelectionRule;
import org.junit.Rule;
import org.junit.Test;

import io.smallrye.mutiny.Uni;
import io.vertx.ext.unit.TestContext;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PersistenceException;
import jakarta.persistence.Table;

/**
 * Test supported types for ids generated by CockroachDB.
 * <p>
 * It won't work with {@link Short} and {@link Integer} because the id generated by CockroachDB don't map
 * those types - they are less than 0 or bigger.
 * </p>
 *
 * @see IdentityGeneratorTest
 * @see IdentityGeneratorTypeTest
 */
public class IdentityGeneratorTypeForCockroachDBTest extends BaseReactiveTest {

	@Rule
	public DatabaseSelectionRule runOnly = runOnlyFor( COCKROACHDB );

	/**
	 * When {@link AvailableSettings#USE_GET_GENERATED_KEYS} is enabled, different
	 * queries will be used for each datastore to get the id
	 */
	public static class EnableUseGetGeneratedKeysTest extends IdentityGeneratorTypeForCockroachDBTest {

		@Override
		protected Configuration constructConfiguration() {
			Configuration configuration = super.constructConfiguration();
			configuration.setProperty( AvailableSettings.USE_GET_GENERATED_KEYS, "true" );
			return configuration;
		}
	}

	@Override
	protected Configuration constructConfiguration() {
		Configuration configuration = super.constructConfiguration();
		// It's the default, but I want to highlight what we are testing
		configuration.setProperty( AvailableSettings.USE_GET_GENERATED_KEYS, "false" );
		return configuration;
	}

	@Override
	public void before(TestContext context) {
		// Do nothing
	}

	@Override
	public void after(TestContext context) {
		super.after( context );
		closeFactory( context );
	}

	@Test
	public void longIdentityType(TestContext context) {
		Configuration configuration = constructConfiguration();
		configuration.addAnnotatedClass( LongTypeEntity.class );

		LongTypeEntity entity = new LongTypeEntity();

		test( context, Uni.createFrom()
				.completionStage( setupSessionFactory( configuration ) )
				.chain( () -> getMutinySessionFactory().withTransaction( s -> s.persist( entity ) ) )
				.invoke( () -> assertThat( entity )
						.isNotNull()
						.satisfies( it -> assertThat( it.id ).isGreaterThan( 0 ) )
				)
		);
	}

	@Test
	public void integerIdentityType(TestContext context) {
		Configuration configuration = constructConfiguration();
		configuration.addAnnotatedClass( IntegerTypeEntity.class );

		test( context, assertThrown( PersistenceException.class, Uni.createFrom()
				.completionStage( setupSessionFactory( configuration ) )
				.chain( () -> getMutinySessionFactory().withTransaction( s -> s.persist( new IntegerTypeEntity() ) ) ) )
				.invoke( exception -> validateErrorMessage( Integer.class, IntegerTypeEntity.class, exception ) )
		);
	}

	@Test
	public void shortIdentityType(TestContext context) {
		Configuration configuration = constructConfiguration();
		configuration.addAnnotatedClass( ShortTypeEntity.class );

		test( context, assertThrown( PersistenceException.class, Uni.createFrom()
					  .completionStage( setupSessionFactory( configuration ) )
					  .chain( () -> getMutinySessionFactory().withTransaction( s -> s.persist( new ShortTypeEntity() ) ) ) )
					  .invoke( exception -> validateErrorMessage( Short.class, ShortTypeEntity.class, exception ) )
		);
	}

	private void validateErrorMessage(Class<?> idType, Class<?> entityType, PersistenceException exception) {
		assertThat( exception.getMessage() )
				.as( "Unexpected error code - this should be a CockroachDB specific issue" )
				.contains( "HR000073" );
		assertThat( exception.getMessage() )
				.as( "Error message should contain the entity name" )
				.contains( entityType.getName() );
		assertThat( exception.getMessage() )
				.as( "Error message should contain the invalid type" )
				.contains( idType.getName() );
		assertThat( exception.getMessage() )
				.as( "Error message should contain the valid type" )
				.contains( Long.class.getName() );
		assertThat( exception.getMessage() )
				.as( "Error message should mention that it happens only for CockroachDB" )
				.contains( "CockroachDB" );
	}

	interface TypeIdentity<T extends Number> {
		T getId();
	}

	@Entity
	@Table(name = "IntegerTypeEntity")
	static class IntegerTypeEntity implements TypeIdentity<Integer> {
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		public Integer id;

		@Override
		public Integer getId() {
			return id;
		}
	}

	@Entity
	@Table(name = "LongTypeEntity")
	static class LongTypeEntity implements TypeIdentity<Long> {
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		public Long id;

		@Override
		public Long getId() {
			return id;
		}
	}

	@Entity
	@Table(name = "ShortTypeEntity")
	static class ShortTypeEntity implements TypeIdentity<Short> {
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		public Short id;

		@Override
		public Short getId() {
			return id;
		}
	}
}
