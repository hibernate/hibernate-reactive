/* Hibernate, Relational Persistence for Idiomatic Java
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright: Red Hat Inc. and Hibernate Authors
 */
package org.hibernate.reactive;

import java.util.Collection;
import java.util.List;

import org.hibernate.cfg.AvailableSettings;
import org.hibernate.cfg.Configuration;
import org.hibernate.reactive.testing.DBSelectionExtension;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.RegisterExtension;

import io.vertx.junit5.VertxTestContext;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.PersistenceException;
import jakarta.persistence.Table;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hibernate.reactive.containers.DatabaseConfiguration.DBType.COCKROACHDB;
import static org.hibernate.reactive.testing.DBSelectionExtension.runOnlyFor;
import static org.hibernate.reactive.testing.ReactiveAssertions.assertThrown;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Test supported types for ids generated by CockroachDB.
 * <p>
 * It won't work with {@link Short} and {@link Integer} because the id generated by CockroachDB don't map
 * those types - they are less than 0 or bigger.
 * </p>
 *
 * @see IdentityGeneratorTest
 * @see IdentityGeneratorTypeTest
 */
public class IdentityGeneratorTypeForCockroachDBTest extends BaseReactiveTest {

	@RegisterExtension
	public DBSelectionExtension runOnly = runOnlyFor( COCKROACHDB );

	/**
	 * When {@link AvailableSettings#USE_GET_GENERATED_KEYS} is enabled, different
	 * queries will be used for each datastore to get the id
	 */
	public static class EnableUseGetGeneratedKeysTest extends IdentityGeneratorTypeForCockroachDBTest {

		@Override
		protected Configuration constructConfiguration() {
			Configuration configuration = super.constructConfiguration();
			configuration.setProperty( AvailableSettings.USE_GET_GENERATED_KEYS, "true" );
			return configuration;
		}
	}

	@Override
	protected Collection<Class<?>> annotatedEntities() {
		return List.of( IntegerTypeEntity.class, LongTypeEntity.class, ShortTypeEntity.class );
	}

	@Override
	protected Configuration constructConfiguration() {
		Configuration configuration = super.constructConfiguration();
		// It's the default, but I want to highlight what we are testing
		configuration.setProperty( AvailableSettings.USE_GET_GENERATED_KEYS, "false" );
		return configuration;
	}

	@Test
	public void longIdentityType(VertxTestContext context) {
		LongTypeEntity entity = new LongTypeEntity();

		test( context, getMutinySessionFactory()
				.withTransaction( s -> s.persist( entity ) )
				.invoke( () -> {
					assertNotNull( entity );
					assertTrue( entity.id > 0 );
				} )
		);
	}

	@Test
	public void integerIdentityType(VertxTestContext context) {
		test( context, assertThrown( PersistenceException.class, getMutinySessionFactory()
				.withTransaction( s -> s.persist( new IntegerTypeEntity() )  ) )
				.invoke( exception -> validateErrorMessage( Integer.class, IntegerTypeEntity.class, exception ) )
		);

	}

	@Test
	public void shortIdentityType(VertxTestContext context) {
		test( context, assertThrown( PersistenceException.class, getMutinySessionFactory()
				.withTransaction( s -> s.persist( new ShortTypeEntity() )  ) )
				.invoke( exception -> validateErrorMessage( Short.class, ShortTypeEntity.class, exception ) )
		);
	}


	private void validateErrorMessage(Class<?> idType, Class<?> entityTYpe, PersistenceException exception) {
		assertThat( exception.getMessage() )
				.as( "Unexpected error code - this should be a CockroachDB specific issue" )
				.contains( "HR000073" );
		assertThat( exception.getMessage() )
				.as( "Error message should contain the entity name" )
				.contains( entityTYpe.getName() );
		assertThat( exception.getMessage() )
				.as( "Error message should contain the invalid type" )
				.contains( idType.getName() );
		assertThat( exception.getMessage() )
				.as( "Error message should contain the valid type" )
				.contains( Long.class.getName() );
		assertThat( exception.getMessage() )
				.as( "Error message should mention that it happens only for CockroachDB" )
				.contains( "CockroachDB" );
	}

	interface TypeIdentity<T extends Number> {
		T getId();
	}

	@Entity
	@Table(name = "IntegerTypeEntity")
	static class IntegerTypeEntity implements TypeIdentity<Integer> {
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		public Integer id;

		@Override
		public Integer getId() {
			return id;
		}
	}

	@Entity
	@Table(name = "LongTypeEntity")
	static class LongTypeEntity implements TypeIdentity<Long> {
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		public Long id;

		@Override
		public Long getId() {
			return id;
		}
	}

	@Entity
	@Table(name = "ShortTypeEntity")
	static class ShortTypeEntity implements TypeIdentity<Short> {
		@Id
		@GeneratedValue(strategy = GenerationType.IDENTITY)
		public Short id;

		@Override
		public Short getId() {
			return id;
		}
	}
}
