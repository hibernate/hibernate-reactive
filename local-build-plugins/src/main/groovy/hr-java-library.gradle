plugins{
	id 'java-library'
	id 'com.diffplug.spotless'
}

group = rootProject.group
version = rootProject.version

spotless {
	//Don't fail during the check: rather than enforcing guidelines, we use this plugin to fix mistakes automatically.
	enforceCheck false
	java {
		licenseHeaderFile rootProject.file('spotless.license.java')
		removeUnusedImports()
		trimTrailingWhitespace()
		endWithNewline()
	}
}

tasks.compileJava.dependsOn(spotlessApply)

repositories {
	// Example: ./gradlew build -PenableMavenLocalRepo
	if ( project.hasProperty('enableMavenLocalRepo') ) {
		// Useful for local development, it should be disabled otherwise
		mavenLocal()
	}
	// Example: ./gradlew build -PenableCentralSonatypeSnapshotsRep
	if ( project.hasProperty('enableCentralSonatypeSnapshotsRep') ) {
		maven { url 'https://central.sonatype.com/repository/maven-snapshots/' }
	}

	mavenCentral()
}

ext.publishScript = rootProject.rootDir.absolutePath + '/publish.gradle'

tasks.withType( JavaCompile ).configureEach {
	options.encoding = 'UTF-8'
}

// Configure test tasks for all subprojects
tasks.withType( Test ).configureEach {
	// Set the project root for finding Docker files - available to all modules
	systemProperty 'hibernate.reactive.project.root', rootProject.projectDir.absolutePath
}

if ( !gradle.ext.javaToolchainEnabled ) {
	sourceCompatibility = JavaVersion.toVersion( gradle.ext.baselineJavaVersion )
	targetCompatibility = JavaVersion.toVersion( gradle.ext.baselineJavaVersion )
}
else {
	// Configure generated bytecode
	// "sourceCompatibility" is not supported with toolchains. We have to work around that limitation.
	tasks.compileJava.configure {
		options.release = gradle.ext.javaVersions.main.release.asInt()
	}
	tasks.compileTestJava.configure {
		options.release = gradle.ext.javaVersions.test.release.asInt()
	}

	// Configure version of Java tools
	java {
		toolchain {
			languageVersion = gradle.ext.javaVersions.main.compiler
		}
	}
	tasks.compileTestJava {
		javaCompiler = javaToolchains.compilerFor {
			languageVersion = gradle.ext.javaVersions.test.compiler
		}
	}
	tasks.test {
		javaLauncher = javaToolchains.launcherFor {
			languageVersion = gradle.ext.javaVersions.test.launcher
		}
	}

	// Configure JVM Options
	tasks.withType( JavaCompile ).configureEach {
		options.forkOptions.jvmArgs.addAll( getProperty( 'toolchain.compiler.jvmargs' ).toString().split( ' ' ) )
	}
	tasks.withType( Javadoc ).configureEach {
		options.setJFlags( getProperty( 'toolchain.javadoc.jvmargs' ).toString().split( ' ' ).toList().findAll( { !it.isEmpty() } ) )
	}
	tasks.test {
		// Configure JVM Options
		jvmArgs(getProperty('toolchain.launcher.jvmargs').toString().split(' '))
		if ( project.hasProperty( 'test.jdk.launcher.args' ) ) {
			jvmArgs( project.getProperty( 'test.jdk.launcher.args' ).toString().split( ' ' ) )
		}
	}

	// Display version of Java tools
	tasks.withType( JavaCompile ).configureEach {
		doFirst {
			logger.lifecycle "Compiling with '${javaCompiler.get().metadata.installationPath}'"
		}
	}
	tasks.withType( Javadoc ).configureEach {
		doFirst {
			logger.lifecycle "Generating javadoc with '${javadocTool.get().metadata.installationPath}'"
		}
	}
	tasks.test {
		doFirst {
			logger.lifecycle "Testing with '${javaLauncher.get().metadata.installationPath}'"
		}
	}
}
